{"version":3,"file":"tdex-sdk.cjs.production.min.js","sources":["../src/core.ts","../src/utils.ts","../src/swap.ts","../src/wallet.ts","../src/trade.ts","../src/grpcClient.ts"],"sourcesContent":["export interface CoreInterface {\n  verbose?: Boolean;\n  chain?: string;\n  providerUrl?: string;\n  explorerUrl?: string;\n}\n\nexport default class Core {\n  public verbose?: Boolean = false;\n  public chain?: string = 'regtest';\n  public providerUrl?: string;\n  public explorerUrl?: string;\n\n  constructor(data?: SafePick<Core>) {\n    Object.assign(this, data);\n  }\n}\n\ntype NonMethodKeys<T> = ({\n  [P in keyof T]: T[P] extends Function ? never : P;\n} & { [x: string]: never })[keyof T];\ntype SafePick<T> = Pick<T, NonMethodKeys<T>>;\n","import JSBI from 'jsbi';\nimport { confidential, Psbt, Transaction } from 'liquidjs-lib';\n\nconst HUNDRED = JSBI.BigInt(100);\nconst TENTHOUSAND = JSBI.multiply(HUNDRED, HUNDRED);\n\nexport function toAssetHash(x: Buffer): string {\n  const withoutFirstByte = x.slice(1);\n  return withoutFirstByte.reverse().toString('hex');\n}\n\nexport function toNumber(x: Buffer): number {\n  return confidential.confidentialValueToSatoshi(x);\n}\n\nfunction minusFee(amount: JSBI, fee: JSBI): Array<JSBI> {\n  const calculatedFee = JSBI.multiply(JSBI.divide(amount, TENTHOUSAND), fee);\n  return [JSBI.subtract(amount, calculatedFee), calculatedFee];\n}\n\nfunction plusFee(amount: JSBI, fee: JSBI): Array<JSBI> {\n  const calculatedFee = JSBI.multiply(JSBI.divide(amount, TENTHOUSAND), fee);\n  return [JSBI.add(amount, calculatedFee), calculatedFee];\n}\n\nexport function calculateExpectedAmount(\n  proposeBalance: number,\n  receiveBalance: number,\n  proposedAmount: number,\n  feeWithDecimals: number\n): number {\n  const PBALANCE = JSBI.BigInt(proposeBalance);\n  const RBALANCE = JSBI.BigInt(receiveBalance);\n  const PAMOUNT = JSBI.BigInt(proposedAmount);\n  const FEE = JSBI.BigInt(feeWithDecimals * 100);\n\n  const invariant = JSBI.multiply(PBALANCE, RBALANCE);\n  const newProposeBalance = JSBI.add(PBALANCE, PAMOUNT);\n  const newReceiveBalance = JSBI.divide(invariant, newProposeBalance);\n  const expectedAmount = JSBI.subtract(RBALANCE, newReceiveBalance);\n  const [expectedAmountMinusFee] = minusFee(expectedAmount, FEE);\n  return JSBI.toNumber(expectedAmountMinusFee);\n}\n\nexport function calculateProposeAmount(\n  proposeBalance: number,\n  receiveBalance: number,\n  expectedAmount: number,\n  feeWithDecimals: number\n): number {\n  const PBALANCE = JSBI.BigInt(proposeBalance);\n  const RBALANCE = JSBI.BigInt(receiveBalance);\n  const RAMOUNT = JSBI.BigInt(expectedAmount);\n  const FEE = JSBI.BigInt(feeWithDecimals * 100);\n\n  const invariant = JSBI.multiply(PBALANCE, RBALANCE);\n  const newReceiveBalance = JSBI.subtract(RBALANCE, RAMOUNT);\n  const newProposeBalance = JSBI.divide(invariant, newReceiveBalance);\n  const proposeAmount = JSBI.subtract(newProposeBalance, PBALANCE);\n  const [proposeAmountPlusFee] = plusFee(proposeAmount, FEE);\n  return JSBI.toNumber(proposeAmountPlusFee);\n}\n\nexport function makeid(length: number): string {\n  let result = '';\n  const characters =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n  const charactersLength = characters.length;\n  for (let i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\n\nexport function decodePsbt(\n  psbtBase64: string\n): { psbt: Psbt; transaction: Transaction } {\n  let psbt: Psbt;\n  try {\n    psbt = Psbt.fromBase64(psbtBase64);\n  } catch (ignore) {\n    throw new Error('Invalid psbt');\n  }\n\n  const bufferTx = psbt.data.globalMap.unsignedTx.toBuffer();\n  const transaction = Transaction.fromBuffer(bufferTx);\n  return {\n    psbt,\n    transaction,\n  };\n}\n\nexport interface UtxoInterface {\n  txid: string;\n  vout: number;\n  asset: string;\n  value: number;\n  script?: string;\n}\n\nexport function coinselect(utxos: Array<UtxoInterface>, amount: number) {\n  let unspents = [];\n  let availableSat = 0;\n  let change = 0;\n\n  for (let i = 0; i < utxos.length; i++) {\n    const utxo = utxos[i];\n    unspents.push({\n      txid: utxo.txid,\n      vout: utxo.vout,\n      value: utxo.value,\n      asset: utxo.asset,\n    });\n    availableSat += utxo.value;\n\n    if (availableSat >= amount) break;\n  }\n\n  if (availableSat < amount)\n    throw new Error('You do not have enough in your wallet');\n\n  change = availableSat - amount;\n\n  return { unspents, change };\n}\n\nexport function isValidAmount(amount: number): boolean {\n  if (amount <= 0 || !Number.isSafeInteger(amount)) return false;\n  return true;\n}\n","import Core from './core';\nimport * as proto from 'tdex-protobuf/js/swap_pb';\nimport { makeid, toNumber, toAssetHash, decodePsbt } from './utils';\n\nexport class Swap extends Core {\n  static parse = parse;\n\n  request({\n    assetToBeSent,\n    amountToBeSent,\n    assetToReceive,\n    amountToReceive,\n    psbtBase64,\n  }: {\n    assetToBeSent: string;\n    amountToBeSent: number;\n    assetToReceive: string;\n    amountToReceive: number;\n    psbtBase64: string;\n  }): Uint8Array {\n    // Check amounts\n\n    const msg = new proto.SwapRequest();\n    msg.setId(makeid(8));\n    msg.setAmountP(amountToBeSent);\n    msg.setAssetP(assetToBeSent);\n    msg.setAmountR(amountToReceive);\n    msg.setAssetR(assetToReceive);\n    msg.setTransaction(psbtBase64);\n\n    compareMessagesAndTransaction(msg);\n\n    if (this.verbose) console.log(msg.toObject());\n\n    return msg.serializeBinary();\n  }\n\n  accept({\n    message,\n    psbtBase64,\n  }: {\n    message: Uint8Array;\n    psbtBase64: string;\n  }): Uint8Array {\n    const msgRequest = proto.SwapRequest.deserializeBinary(message);\n    // Build Swap Accepr message\n    const msgAccept = new proto.SwapAccept();\n    msgAccept.setId(makeid(8));\n    msgAccept.setRequestId(msgRequest.getId());\n    msgAccept.setTransaction(psbtBase64);\n\n    compareMessagesAndTransaction(msgRequest, msgAccept);\n\n    if (this.verbose) console.log(msgAccept.toObject());\n\n    return msgAccept.serializeBinary();\n  }\n\n  complete({\n    message,\n    psbtBase64,\n  }: {\n    message: Uint8Array;\n    psbtBase64: string;\n  }): Uint8Array {\n    //First validate signatures\n    const { psbt } = decodePsbt(psbtBase64);\n\n    if (!psbt.validateSignaturesOfAllInputs())\n      throw new Error('Signatures not valid');\n\n    const msgAccept = proto.SwapAccept.deserializeBinary(message);\n    //Build SwapComplete\n    const msgComplete = new proto.SwapComplete();\n    msgComplete.setId(makeid(8));\n    msgComplete.setAcceptId(msgAccept.getId());\n    msgComplete.setTransaction(psbtBase64);\n\n    if (this.verbose) console.log(msgAccept.toObject());\n\n    return msgComplete.serializeBinary();\n  }\n}\n\nfunction compareMessagesAndTransaction(\n  msgRequest: proto.SwapRequest,\n  msgAccept?: proto.SwapAccept\n) {\n  const decodedFromRequest = decodePsbt(msgRequest.getTransaction());\n\n  const totalP = countUtxos(\n    decodedFromRequest.psbt.data.inputs,\n    msgRequest.getAssetP()\n  );\n  if (totalP < msgRequest.getAmountP())\n    throw new Error(\n      'Cumulative utxos count is not enough to cover SwapRequest.amount_p'\n    );\n\n  const outputRFound = outputFoundInTransaction(\n    decodedFromRequest.transaction.outs,\n    msgRequest.getAmountR(),\n    msgRequest.getAssetR()\n  );\n  if (!outputRFound)\n    throw new Error(\n      'Either SwapRequest.amount_r or SwapRequest.asset_r do not match the provided psbt'\n    );\n\n  if (msgAccept) {\n    const decodedFromAccept = decodePsbt(msgAccept.getTransaction());\n    if (msgRequest.getId() !== msgAccept.getRequestId())\n      throw new Error(\n        'SwapRequest.id and SwapAccept.request_id are not the same'\n      );\n\n    const totalR = countUtxos(\n      decodedFromAccept.psbt.data.inputs,\n      msgRequest.getAssetR()\n    );\n    if (totalR < msgRequest.getAmountR())\n      throw new Error(\n        'Cumulative utxos count is not enough to cover SwapRequest.amount_r'\n      );\n\n    const outputPFound = outputFoundInTransaction(\n      decodedFromAccept.transaction.outs,\n      msgRequest.getAmountP(),\n      msgRequest.getAssetP()\n    );\n    if (!outputPFound)\n      throw new Error(\n        'Either SwapRequest.amount_p or SwapRequest.asset_p do not match the provided psbt'\n      );\n  }\n}\n\nfunction outputFoundInTransaction(\n  outputs: Array<any>,\n  value: number,\n  asset: string\n) {\n  const found = outputs.find(\n    (o: any) => toNumber(o.value) === value && toAssetHash(o.asset) === asset\n  );\n\n  return found !== undefined;\n}\n\nfunction countUtxos(utxos: Array<any>, asset: string): number {\n  return utxos\n    .filter((i: any) => toAssetHash(i.witnessUtxo!.asset) === asset)\n    .map((i: any) => toNumber(i.witnessUtxo!.value))\n    .reduce((a: any, b: any) => a + b, 0);\n}\n\nfunction parse({\n  message,\n  type,\n}: {\n  message: Uint8Array;\n  type: string;\n}): string {\n  let msg: any;\n  try {\n    msg = (proto as any)[type].deserializeBinary(message);\n  } catch (e) {\n    throw new Error(`Not valid message of expected type ${type}`);\n  }\n\n  return JSON.stringify(msg.toObject(), undefined, 2);\n}\n","import axios from 'axios';\nimport { ECPair, networks, payments, Psbt, confidential } from 'liquidjs-lib';\n//Libs\nimport { coinselect } from './utils';\n//Types\nimport { ECPairInterface } from 'liquidjs-lib/types/ecpair';\nimport { Network } from 'liquidjs-lib/types/networks';\n\nexport interface WatchOnlyWalletInterface {\n  address: string;\n  script: string;\n  network: Network;\n  updateTx(\n    psbtBase64: string,\n    inputs: Array<any>,\n    inputAmount: number,\n    outputAmount: number,\n    inputAsset: string,\n    outputAsset: string\n  ): string;\n}\n\nexport class WatchOnlyWallet implements WatchOnlyWalletInterface {\n  network: Network;\n  address: string;\n  script: string;\n  constructor({ address, network }: { address: string; network: Network }) {\n    const payment = payments.p2wpkh({ address, network });\n\n    this.network = network;\n    this.address = payment.address!;\n    this.script = payment.output!.toString('hex');\n  }\n\n  static fromAddress = fromAddress;\n  static createTx = createTx;\n  static toHex = toHex;\n\n  updateTx(\n    psbtBase64: string,\n    inputs: Array<any>,\n    inputAmount: number,\n    outputAmount: number,\n    inputAsset: string,\n    outputAsset: string\n  ): string {\n    let psbt: Psbt;\n    try {\n      psbt = Psbt.fromBase64(psbtBase64);\n    } catch (ignore) {\n      throw new Error('Invalid psbt');\n    }\n\n    inputs = inputs.filter((utxo: any) => utxo.asset === inputAsset);\n    const { unspents, change } = coinselect(inputs, inputAmount);\n\n    unspents.forEach((i: any) =>\n      psbt.addInput({\n        // if hash is string, txid, if hash is Buffer, is reversed compared to txid\n        hash: i.txid,\n        index: i.vout,\n        //The scriptPubkey and the value only are needed.\n        witnessUtxo: {\n          script: Buffer.from(this.script, 'hex'),\n          asset: Buffer.concat([\n            Buffer.from('01', 'hex'), //prefix for unconfidential asset\n            Buffer.from(inputAsset, 'hex').reverse(),\n          ]),\n          value: confidential.satoshiToConfidentialValue(i.value),\n          nonce: Buffer.from('00', 'hex'),\n        },\n      } as any)\n    );\n\n    psbt.addOutput({\n      script: Buffer.from(this.script, 'hex'),\n      value: confidential.satoshiToConfidentialValue(outputAmount),\n      asset: Buffer.concat([\n        Buffer.from('01', 'hex'), //prefix for unconfidential asset\n        Buffer.from(outputAsset, 'hex').reverse(),\n      ]),\n      nonce: Buffer.from('00', 'hex'),\n    });\n\n    if (change > 0) {\n      psbt.addOutput({\n        script: Buffer.from(this.script, 'hex'),\n        value: confidential.satoshiToConfidentialValue(change),\n        asset: Buffer.concat([\n          Buffer.from('01', 'hex'), //prefix for unconfidential asset\n          Buffer.from(inputAsset, 'hex').reverse(),\n        ]),\n        nonce: Buffer.from('00', 'hex'),\n      });\n    }\n\n    const base64 = psbt.toBase64();\n    return base64;\n  }\n}\n\nexport interface WalletInterface extends WatchOnlyWalletInterface {\n  keyPair: ECPairInterface;\n  privateKey: string;\n  publicKey: string;\n  sign(psbtBase64: string): string;\n}\n\nexport class Wallet extends WatchOnlyWallet implements WalletInterface {\n  keyPair: ECPairInterface;\n  privateKey: string;\n  publicKey: string;\n\n  static fromWIF = fromWIF;\n  static fromRandom = fromRandom;\n\n  constructor({\n    network,\n    address,\n    keyPair,\n  }: {\n    network: Network;\n    address: string;\n    keyPair: ECPairInterface | undefined;\n  }) {\n    super({ network, address });\n\n    if (!keyPair) this.keyPair = ECPair.makeRandom({ network: this.network });\n    else this.keyPair = keyPair;\n\n    this.privateKey = this.keyPair.privateKey!.toString('hex');\n    this.publicKey = this.keyPair.publicKey!.toString('hex');\n  }\n\n  updateTx = super.updateTx;\n\n  sign(psbtBase64: string): string {\n    let psbt: Psbt;\n    try {\n      psbt = Psbt.fromBase64(psbtBase64);\n    } catch (ignore) {\n      throw new Error('Invalid psbt');\n    }\n\n    psbt.data.inputs.forEach((p: any, i: number) => {\n      if (p.witnessUtxo!.script.toString('hex') === this.script) {\n        psbt.signInput(i, this.keyPair);\n        if (!psbt.validateSignaturesOfInput(i))\n          throw new Error('Invalid signature');\n      }\n    });\n\n    return psbt.toBase64();\n  }\n}\n\nfunction fromAddress(\n  address: string,\n  network?: string\n): WatchOnlyWalletInterface {\n  const _network = network ? (networks as any)[network] : networks.liquid;\n\n  try {\n    return new WatchOnlyWallet({\n      address,\n      network: _network,\n    });\n  } catch (ignore) {\n    throw new Error('fromAddress: Invalid address or network');\n  }\n}\n\nfunction fromRandom(network?: string): WalletInterface {\n  const _network = network ? (networks as any)[network] : networks.liquid;\n  try {\n    const keyPair = ECPair.makeRandom({ network: _network });\n    const { address } = payments.p2wpkh({\n      pubkey: keyPair.publicKey,\n      network: _network,\n    });\n    return new Wallet({ keyPair, network: _network, address: address! });\n  } catch (ignore) {\n    throw new Error('fromRandom: Failed to create wallet');\n  }\n}\n\nfunction fromWIF(wif: string, network?: string): WalletInterface {\n  const _network = network ? (networks as any)[network] : networks.liquid;\n\n  try {\n    const keyPair = ECPair.fromWIF(wif, _network);\n    const { address } = payments.p2wpkh({\n      pubkey: keyPair.publicKey,\n      network: _network,\n    });\n    return new Wallet({ keyPair, network: _network, address: address! });\n  } catch (ignore) {\n    throw new Error('fromWIF: Invalid keypair');\n  }\n}\n\nfunction createTx(network?: string): string {\n  const _network = network ? (networks as any)[network] : networks.liquid;\n  const psbt = new Psbt({ network: _network });\n  return psbt.toBase64();\n}\n\nfunction toHex(psbtBase64: string): string {\n  let psbt: Psbt;\n  try {\n    psbt = Psbt.fromBase64(psbtBase64);\n  } catch (ignore) {\n    throw new Error('Invalid psbt');\n  }\n\n  psbt.validateSignaturesOfAllInputs();\n  psbt.finalizeAllInputs();\n\n  return psbt.extractTransaction().toHex();\n}\n\nexport async function fetchUtxos(address: string, url: string): Promise<any> {\n  return (await axios.get(`${url}/address/${address}/utxo`)).data;\n}\n\nexport async function fetchBalances(address: string, url: string) {\n  const utxos = await fetchUtxos(address, url);\n  return utxos.reduce(\n    (storage: { [x: string]: any }, item: { [x: string]: any; value: any }) => {\n      // get the first instance of the key by which we're grouping\n      var group = item['asset'];\n\n      // set `storage` for this instance of group to the outer scope (if not empty) or initialize it\n      storage[group] = storage[group] || 0;\n\n      // add this item to its group within `storage`\n      storage[group] += item.value;\n\n      // return the updated storage to the reduce function, which will then loop through the next\n      return storage;\n    },\n    {}\n  ); // {} is the initial value of the storage\n}\n","import Core, { CoreInterface } from './core';\nimport { Swap } from './swap';\nimport {\n  WalletInterface,\n  WatchOnlyWalletInterface,\n  Wallet,\n  WatchOnlyWallet,\n  fetchUtxos,\n} from './wallet';\nimport { TraderClient } from './grpcClient';\nimport TraderClientInterface from './grpcClientInterface';\nimport {\n  calculateExpectedAmount,\n  calculateProposeAmount,\n  isValidAmount,\n} from './utils';\nimport { SwapAccept } from 'tdex-protobuf/js/swap_pb';\n\nexport interface MarketInterface {\n  baseAsset: string;\n  quoteAsset: string;\n}\n\nexport enum TradeType {\n  BUY = 0,\n  SELL = 1,\n}\n\nexport class Trade extends Core implements CoreInterface {\n  private grpcClient: TraderClientInterface;\n\n  constructor(args: CoreInterface) {\n    super(args);\n\n    if (!this.chain)\n      throw new Error(\n        'To be able to trade you need to select the network via { chain }'\n      );\n\n    if (!this.providerUrl)\n      throw new Error(\n        'To be able to trade you need to select a liquidity provider via { providerUrl }'\n      );\n\n    if (!this.explorerUrl)\n      throw new Error(\n        'To be able to trade you need to select an explorer via { explorerUrl }'\n      );\n\n    this.grpcClient = new TraderClient(this.providerUrl);\n  }\n\n  /**\n   * Trade.buy let the trder buy the baseAsset,\n   * sending his own quoteAsset using the current market price\n   */\n  async buy({\n    market,\n    amount,\n    address,\n    privateKey,\n  }: {\n    market: MarketInterface;\n    amount: number; //this is fractional amount\n    address?: string;\n    privateKey?: string;\n  }): Promise<Uint8Array | string> {\n    if (!privateKey && !address)\n      throw new Error(\n        'Either private key or native segwit address is required'\n      );\n\n    if (!privateKey) {\n      const watchOnlyWallet: WatchOnlyWalletInterface = WatchOnlyWallet.fromAddress(\n        address!,\n        this.chain!\n      );\n      const swapAccept = await this.marketOrderRequest(\n        market,\n        TradeType.BUY,\n        amount,\n        watchOnlyWallet\n      );\n      return swapAccept;\n    } else {\n      const wallet: WalletInterface = Wallet.fromWIF(privateKey, this.chain!);\n      const swapAccept = await this.marketOrderRequest(\n        market,\n        TradeType.BUY,\n        amount,\n        wallet\n      );\n      const txid = await this.marketOrderComplete(swapAccept, wallet);\n      return txid;\n    }\n  }\n\n  /**\n   * Trade.sell let the trder sell the baseAsset,\n   * receiving the quoteAsset using the current market price\n   */\n\n  async sell({\n    market,\n    amount,\n    address,\n    privateKey,\n  }: {\n    market: MarketInterface;\n    amount: number; // this is fractional amount\n    address?: string;\n    privateKey?: string;\n  }): Promise<Uint8Array | string> {\n    if (!privateKey && !address)\n      throw new Error(\n        'Either private key or native segwit address is required'\n      );\n\n    if (!privateKey) {\n      const watchOnlyWallet: WatchOnlyWalletInterface = WatchOnlyWallet.fromAddress(\n        address!,\n        this.chain!\n      );\n      const swapAccept = await this.marketOrderRequest(\n        market,\n        TradeType.SELL,\n        amount,\n        watchOnlyWallet\n      );\n      return swapAccept;\n    } else {\n      const wallet: WalletInterface = Wallet.fromWIF(privateKey, this.chain!);\n      const swapAccept = await this.marketOrderRequest(\n        market,\n        TradeType.SELL,\n        amount,\n        wallet\n      );\n      const txid = await this.marketOrderComplete(swapAccept, wallet);\n      return txid;\n    }\n  }\n\n  async preview(\n    market: MarketInterface,\n    tradeType: TradeType,\n    amountInSatoshis: number\n  ): Promise<any> {\n    if (!isValidAmount(amountInSatoshis)) {\n      throw new Error('Amount is not valid');\n    }\n    const { baseAsset, quoteAsset } = market;\n\n    const balancesAndFee = await this.grpcClient.balances({\n      baseAsset,\n      quoteAsset,\n    });\n\n    if (tradeType === TradeType.BUY) {\n      const assetToBeSent = quoteAsset;\n      const assetToReceive = baseAsset;\n      const amountToReceive = amountInSatoshis;\n\n      if (amountToReceive > balancesAndFee.balances[assetToReceive])\n        throw new Error('Amount exceeds market balance');\n\n      const amountToBeSent = calculateProposeAmount(\n        balancesAndFee.balances[assetToBeSent],\n        balancesAndFee.balances[assetToReceive],\n        amountToReceive,\n        balancesAndFee.fee\n      );\n\n      return {\n        assetToBeSent,\n        amountToBeSent,\n        assetToReceive,\n        amountToReceive,\n      };\n    } else {\n      const assetToBeSent = baseAsset;\n      const assetToReceive = quoteAsset;\n      const amountToBeSent = amountInSatoshis;\n\n      if (amountToBeSent > balancesAndFee.balances[assetToBeSent])\n        throw new Error('Amount exceeds market balance');\n\n      const amountToReceive = calculateExpectedAmount(\n        balancesAndFee.balances[assetToBeSent],\n        balancesAndFee.balances[assetToReceive],\n        amountToBeSent,\n        balancesAndFee.fee\n      );\n\n      return {\n        assetToBeSent,\n        amountToBeSent,\n        assetToReceive,\n        amountToReceive,\n      };\n    }\n  }\n\n  private async marketOrderRequest(\n    market: MarketInterface,\n    tradeType: TradeType,\n    amountInSatoshis: number,\n    wallet: WalletInterface | WatchOnlyWalletInterface\n  ): Promise<Uint8Array> {\n    const {\n      assetToBeSent,\n      amountToBeSent,\n      assetToReceive,\n      amountToReceive,\n    } = await this.preview(market, tradeType, amountInSatoshis);\n\n    const traderUtxos = await fetchUtxos(wallet.address, this.explorerUrl!);\n\n    const emptyPsbt = Wallet.createTx(this.chain);\n    const psbtBase64 = wallet.updateTx(\n      emptyPsbt,\n      traderUtxos,\n      amountToBeSent,\n      amountToReceive,\n      assetToBeSent,\n      assetToReceive\n    );\n\n    const swap = new Swap();\n    const swapRequestSerialized = swap.request({\n      assetToBeSent,\n      amountToBeSent,\n      assetToReceive,\n      amountToReceive,\n      psbtBase64,\n    });\n\n    // 0 === Buy === receiving base_asset; 1 === sell === receiving base_asset\n    const swapAcceptSerialized: Uint8Array = await this.grpcClient.tradePropose(\n      market,\n      tradeType,\n      swapRequestSerialized\n    );\n\n    return swapAcceptSerialized;\n  }\n\n  private async marketOrderComplete(\n    swapAcceptSerialized: Uint8Array,\n    wallet: WalletInterface\n  ): Promise<string> {\n    // trader need to check the signed inputs by the provider\n    // and add his own inputs if all is correct\n    const swapAcceptMessage = SwapAccept.deserializeBinary(\n      swapAcceptSerialized\n    );\n    const transaction = swapAcceptMessage.getTransaction();\n    const signedPsbt = wallet.sign(transaction);\n\n    // Trader  adds his signed inputs to the transaction\n    const swap = new Swap();\n    const swapCompleteSerialized = swap.complete({\n      message: swapAcceptSerialized,\n      psbtBase64: signedPsbt,\n    });\n\n    // Trader call the tradeComplete endpoint to finalize the swap\n    const txid = await this.grpcClient.tradeComplete(swapCompleteSerialized);\n    return txid;\n  }\n}\n","import * as grpc from '@grpc/grpc-js';\nimport * as services from 'tdex-protobuf/js/trade_grpc_pb';\nimport * as messages from 'tdex-protobuf/js/trade_pb';\nimport { SwapRequest, SwapComplete } from 'tdex-protobuf/js/swap_pb';\n\nimport TraderClientInterface from './grpcClientInterface';\n\nexport class TraderClient implements TraderClientInterface {\n  providerUrl: string;\n  client: services.TradeClient;\n  constructor(providerUrl: string) {\n    this.providerUrl = providerUrl;\n    this.client = new services.TradeClient(\n      providerUrl,\n      grpc.credentials.createInsecure()\n    );\n  }\n\n  /**\n   * tradePropose\n   * @param market\n   * @param tradeType\n   * @param swapRequestSerialized\n   */\n\n  tradePropose(\n    { baseAsset, quoteAsset }: any,\n    tradeType: number,\n    swapRequestSerialized: Uint8Array\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const market = new messages.Market();\n      market.setBaseAsset(baseAsset);\n      market.setQuoteAsset(quoteAsset);\n\n      const request = new messages.TradeProposeRequest();\n      request.setMarket(market);\n      request.setType(tradeType);\n      request.setSwapRequest(\n        SwapRequest.deserializeBinary(swapRequestSerialized)\n      );\n\n      const call = this.client.tradePropose(request);\n      let data: Uint8Array;\n      call.on('data', (reply: messages.TradeProposeReply) => {\n        const swapAcceptMsg = reply!.getSwapAccept();\n        data = swapAcceptMsg!.serializeBinary();\n      });\n\n      call.on('end', () => resolve(data));\n      call.on('error', (e: any) => reject(e));\n    });\n  }\n\n  /**\n   * tradeComplete\n   * @param swapCompleteSerialized\n   */\n\n  tradeComplete(swapCompleteSerialized: Uint8Array): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const request = new messages.TradeCompleteRequest();\n      request.setSwapComplete(\n        SwapComplete.deserializeBinary(swapCompleteSerialized)\n      );\n      const call = this.client.tradeComplete(request);\n      let data: string;\n      call.on('data', (reply: messages.TradeCompleteReply) => {\n        data = reply!.getTxid();\n      });\n      call.on('end', () => resolve(data));\n      call.on('error', (e: any) => reject(e));\n    });\n  }\n\n  markets(): Promise<Array<any>> {\n    return new Promise((resolve, reject) => {\n      this.client.markets(new messages.MarketsRequest(), (err, response) => {\n        if (err) return reject(err);\n        const list = response!\n          .getMarketsList()\n          .map((item: any) => item!.getMarket())\n          .map((market: any) => ({\n            baseAsset: market!.getBaseAsset(),\n            quoteAsset: market!.getQuoteAsset(),\n          }));\n        resolve(list);\n      });\n    });\n  }\n\n  balances({\n    baseAsset,\n    quoteAsset,\n  }: {\n    baseAsset: string;\n    quoteAsset: string;\n  }): Promise<any> {\n    const market = new messages.Market();\n    market.setBaseAsset(baseAsset);\n    market.setQuoteAsset(quoteAsset);\n    const request = new messages.BalancesRequest();\n    request.setMarket(market);\n\n    return new Promise((resolve, reject) => {\n      this.client.balances(request, (err, response) => {\n        if (err) return reject(err);\n\n        const baseAmount: number = response\n          .getBalancesList()\n          .find(b => b.getAsset() === baseAsset)!\n          .getAmount();\n        const quoteAmount: number = response\n          .getBalancesList()\n          .find(b => b.getAsset() === quoteAsset)!\n          .getAmount();\n        const reply = {\n          fee: response!.getFee(),\n          balances: {\n            [baseAsset]: baseAmount,\n            [quoteAsset]: quoteAmount,\n          },\n        };\n        resolve(reply);\n      });\n    });\n  }\n}\n"],"names":["Core","data","Object","assign","this","HUNDRED","JSBI","BigInt","TENTHOUSAND","multiply","toAssetHash","x","slice","reverse","toString","toNumber","confidential","confidentialValueToSatoshi","calculateExpectedAmount","proposeBalance","receiveBalance","proposedAmount","feeWithDecimals","amount","fee","calculatedFee","PBALANCE","RBALANCE","PAMOUNT","FEE","invariant","newProposeBalance","add","newReceiveBalance","divide","expectedAmount","subtract","calculateProposeAmount","RAMOUNT","proposeAmount","makeid","length","result","characters","charactersLength","i","charAt","Math","floor","random","decodePsbt","psbtBase64","psbt","Psbt","fromBase64","ignore","Error","bufferTx","globalMap","unsignedTx","toBuffer","transaction","Transaction","fromBuffer","Swap","request","assetToBeSent","amountToBeSent","assetToReceive","amountToReceive","msg","proto","setId","setAmountP","setAssetP","setAmountR","setAssetR","setTransaction","compareMessagesAndTransaction","verbose","console","log","toObject","serializeBinary","accept","msgRequest","deserializeBinary","message","msgAccept","setRequestId","getId","complete","validateSignaturesOfAllInputs","msgComplete","setAcceptId","decodedFromRequest","getTransaction","countUtxos","inputs","getAssetP","getAmountP","outputFoundInTransaction","outs","getAmountR","getAssetR","decodedFromAccept","getRequestId","outputs","value","asset","undefined","find","o","utxos","filter","witnessUtxo","map","reduce","a","b","type","e","JSON","stringify","fetchUtxos","address","url","axios","get","_axios$get","WatchOnlyWallet","network","payment","payments","p2wpkh","script","output","updateTx","inputAmount","outputAmount","inputAsset","outputAsset","unspents","availableSat","utxo","push","txid","vout","change","coinselect","forEach","addInput","hash","index","Buffer","from","_this","concat","satoshiToConfidentialValue","nonce","addOutput","toBase64","_network","networks","liquid","finalizeAllInputs","extractTransaction","toHex","Wallet","keyPair","_this2","ECPair","makeRandom","privateKey","publicKey","sign","p","_this3","signInput","validateSignaturesOfInput","wif","fromWIF","pubkey","TradeType","TraderClient","providerUrl","client","services","grpc","createInsecure","tradePropose","tradeType","swapRequestSerialized","baseAsset","quoteAsset","Promise","resolve","reject","market","messages","setBaseAsset","setQuoteAsset","setMarket","setType","setSwapRequest","SwapRequest","call","on","reply","swapAcceptMsg","getSwapAccept","tradeComplete","swapCompleteSerialized","setSwapComplete","SwapComplete","getTxid","markets","err","response","list","getMarketsList","item","getMarket","getBaseAsset","getQuoteAsset","balances","_this4","baseAmount","getBalancesList","getAsset","getAmount","quoteAmount","getFee","Trade","args","chain","explorerUrl","grpcClient","buy","wallet","marketOrderRequest","BUY","swapAccept","marketOrderComplete","watchOnlyWallet","fromAddress","sell","_this5","SELL","preview","amountInSatoshis","Number","isSafeInteger","balancesAndFee","_this9","traderUtxos","emptyPsbt","createTx","swapAcceptSerialized","SwapAccept","signedPsbt","storage","group"],"mappings":"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"}